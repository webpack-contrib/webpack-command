#!/usr/bin/env node

if (!module.parent) {
  // eslint-disable-next-line global-require
  const { register } = require('./global');

  register();
}

const debug = require('debug')('webpack-command');
const importLocal = require('import-local'); // eslint-disable-line import/order
const weblog = require('webpack-log');

// Prefer the local installation of webpack-command
/* istanbul ignore if */
if (importLocal(__filename)) {
  debug('Using local install of webpack-command');
} else {
  run();
}

function run() {
  /* eslint-disable global-require */
  const { existsSync: exists, statSync: stat } = require('fs');
  const { sep } = require('path');
  const { inspect } = require('util');

  const chalk = require('chalk');
  const meow = require('meow');

  const woof = require('./');
  const { help: commandHelp, load: getCommands } = require('./commands');
  const { help: flagHelp, opts } = require('./flags');
  /* eslint-enable global-require */

  const flagOpts = { flags: opts() };
  const log = weblog({ name: 'command', id: 'webpack-command-forced' });
  const cli = meow(
    chalk`
{underline Usage}
  $ webpack [<config>, ...options]
  $ webpack <entry-file> [...<entry-file>] <output-file>

{underline Options}
${flagHelp()}

  For further documentation, visit {blue https://webpack.js.org/api/cli}

{underline Commands}
${commandHelp()}

  Type \`webpack help <command>\` for more information

{underline Examples}
  $ webpack
  $ webpack --help
  $ webpack entry.js
  $ webpack --config ../webpack.config.js
`,
    flagOpts
  );

  const commands = getCommands();
  const [command] = cli.input;

  cli.argv = cli.flags;
  cli.commands = commands;
  cli.entries = [];

  const cmd = cli.commands[command];

  if (cmd) {
    try {
      cmd.run(cli);
    } catch (e) {
      log.error(chalk`The {bold \`${command}\`} command threw an error:`);
      throw e;
    }
  } else {
    if (cli.input.length) {
      const problems = [];
      const isDir = (path) => stat(path).isDirectory();
      const entries = [];

      for (let file of cli.input) {
        if (!exists(file)) {
          problems.push(file);
        } else {
          if (isDir(file)) {
            file += sep;
          }

          entries.push(file);
        }
      }

      if (problems.length) {
        const prefix =
          problems.length === cli.input.length ? 'The' : 'Some of the';
        const message = `${prefix} input provided did not match any known commands or existing files:
            ${problems.join(' ')}`;
        log.error(message);

        /* istanbul ignore else */
        if (process.env.CLI_TEST === 'true') {
          throw new Error(message);
        } else {
          // citing: http://www.tldp.org/LDP/abs/html/exitcodes.html
          process.exit(127);
        }
      }

      cli.entries = entries;
    }

    woof(cli).catch((e) => {
      let error = e;
      const errorType = error.constructor.name;
      const epilogue = chalk`: {dim use --log-level=debug for more error detail}`;
      let preamble = 'A webpack error occured while building';
      let logStack = true;

      // NOTE: none of these conditionals need coverage. the catch has coverage
      //       and that's what is important

      /* istanbul ignore if */
      if (!(error instanceof Error)) {
        error = new Error(
          `webpack-command failed with a value of: ${inspect(error)}`
        );
      }

      // Assume that errors are generated by webpack first: e.g. ModuleNotFoundError
      // If it's a WebpackCommandError then we goofed somehow.
      // If it's a generic Error it's likely that webpack is throwing a poorly
      // managed error, or a plugin has done something naughty.
      /* istanbul ignore if|else */
      if (errorType === 'WebpackCommandError') {
        preamble = 'An error occured while running webpack-command';
      } else if (errorType === 'Error') {
        /* istanbul ignore next */
        preamble = 'An error occured while running webpack';
      } else {
        logStack = false;
      }

      log.error(preamble + epilogue);

      /* istanbul ignore if */
      if (logStack) {
        log.error(error.stack);
      } else {
        log.error(error.message);
      }

      /* istanbul ignore if */
      if (cli.flags.logLevel === 'debug') {
        log.level = cli.flags.logLevel;
      }

      log.debug(inspect(error));

      process.exitCode = 1;
    });
  }
}
